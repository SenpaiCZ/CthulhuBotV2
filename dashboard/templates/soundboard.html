{% extends 'base.html' %}

{% block title %}Soundboard{% endblock %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-4">
    <h2>Soundboard</h2>
    <div>
        <a href="/admin" class="btn btn-secondary">Back to Admin</a>
    </div>
</div>

<div id="loading" class="alert alert-info">Loading soundboard data...</div>
<div id="error" class="alert alert-danger d-none"></div>

<div id="app-content" class="d-none">
    <div class="row mb-4">
        <div class="col-md-4">
            <label for="guildSelect" class="form-label">Server</label>
            <select id="guildSelect" class="form-select">
                <!-- Options populated by JS -->
            </select>
        </div>
        <div class="col-md-4">
            <label for="channelSelect" class="form-label">Voice Channel</label>
            <select id="channelSelect" class="form-select">
                <!-- Options populated by JS -->
            </select>
        </div>
        <div class="col-md-4">
            <label class="form-label">Controls</label>
            <div class="d-flex gap-2">
                <button id="stopBtn" class="btn btn-danger w-100">Stop</button>
            </div>
            <div class="mt-2">
                 <label for="volumeRange" class="form-label d-flex justify-content-between">
                    <span>Volume</span> <span id="volumeValue">50%</span>
                </label>
                <input type="range" class="form-range" id="volumeRange" min="0" max="100">
            </div>
        </div>
    </div>

    <div class="alert alert-info" id="statusIndicator">
        Status: <span id="connectionStatus">Disconnected</span>
    </div>

    <div id="soundboard-files">
        <!-- Files populated by JS -->
    </div>
</div>

<script>
    let currentData = null;
    let selectedGuildId = null;

    async function fetchData() {
        try {
            const response = await fetch('/api/soundboard/data');
            const data = await response.json();
            currentData = data;
            render();
        } catch (e) {
            console.error(e);
            document.getElementById('error').textContent = "Failed to load data. Ensure the bot is running.";
            document.getElementById('error').classList.remove('d-none');
            document.getElementById('loading').classList.add('d-none');
        }
    }

    function render() {
        document.getElementById('loading').classList.add('d-none');
        document.getElementById('app-content').classList.remove('d-none');

        const guildSelect = document.getElementById('guildSelect');
        const channelSelect = document.getElementById('channelSelect');
        const filesContainer = document.getElementById('soundboard-files');
        const connectionStatus = document.getElementById('connectionStatus');
        const volumeRange = document.getElementById('volumeRange');
        const volumeValue = document.getElementById('volumeValue');

        // Populate Guilds
        if (guildSelect.options.length === 0) {
            currentData.guilds.forEach(guild => {
                const opt = document.createElement('option');
                opt.value = guild.id;
                opt.textContent = guild.name;
                guildSelect.appendChild(opt);
            });
            if (currentData.guilds.length > 0) {
                selectedGuildId = currentData.guilds[0].id;
            }
        } else {
             // Keep selected or update if none
             if (!selectedGuildId && guildSelect.value) selectedGuildId = guildSelect.value;
        }

        if (!selectedGuildId) {
             filesContainer.innerHTML = '<div class="alert alert-warning">No servers found. Make sure the bot is in a server.</div>';
             return;
        }

        // Sync select with variable
        guildSelect.value = selectedGuildId;

        // Find current guild data
        const guildData = currentData.guilds.find(g => g.id === selectedGuildId);
        const status = currentData.status[selectedGuildId];

        if (!guildData) return;

        // Populate Channels
        const currentChannelId = channelSelect.value;

        // Save current options to check if we need to rebuild (avoid flickering)
        const newOptions = guildData.channels.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
        if (channelSelect.innerHTML !== newOptions) {
             channelSelect.innerHTML = newOptions;
        }

        // Select active channel if connected, otherwise keep selection or default
        if (status.is_connected && status.channel_id) {
            channelSelect.value = status.channel_id;
        } else if (currentChannelId) {
             // Try to keep selection
             const exists = guildData.channels.find(c => c.id === currentChannelId);
             if (exists) channelSelect.value = currentChannelId;
        }

        // Update Status
        if (status.is_connected) {
            connectionStatus.textContent = `Connected to ${status.channel_id} ${status.is_playing ? '(Playing)' : '(Idle)'}`;
            connectionStatus.className = status.is_playing ? 'text-success fw-bold' : 'text-primary';
        } else {
            connectionStatus.textContent = 'Disconnected';
            connectionStatus.className = 'text-muted';
        }

        // Update Volume UI if it hasn't been touched yet or if we just switched guilds
        if (document.activeElement !== volumeRange) {
             volumeRange.value = status.volume;
             volumeValue.textContent = status.volume + '%';
        }

        // Files Render
        // Only re-render if empty to avoid destroying event listeners or extensive DOM updates
        if (filesContainer.childElementCount === 0) {
             filesContainer.innerHTML = '';

             // Helper to create file button
            const createButton = (file) => {
                const btn = document.createElement('button');
                btn.className = 'btn btn-outline-primary m-1';
                // btn.innerHTML = `<i class="bi bi-play-fill"></i> ${file.name}`;
                btn.innerText = `â–¶ ${file.name}`;
                btn.onclick = () => playSound(file.path);
                return btn;
            };

            // Render Root
            if (currentData.files.Root) {
                const rootCard = document.createElement('div');
                rootCard.className = 'card mb-3';
                rootCard.innerHTML = '<div class="card-header">Uncategorized</div><div class="card-body" id="root-files"></div>';
                filesContainer.appendChild(rootCard);
                const rootBody = rootCard.querySelector('#root-files');
                currentData.files.Root.forEach(f => rootBody.appendChild(createButton(f)));
            }

            // Render Folders
            Object.keys(currentData.files).forEach(key => {
                if (key === 'Root') return;

                const card = document.createElement('div');
                card.className = 'card mb-3';
                card.innerHTML = `<div class="card-header">${key}</div><div class="card-body" id="folder-${key}"></div>`;
                filesContainer.appendChild(card);
                const body = card.querySelector(`#folder-${key}`);
                currentData.files[key].forEach(f => body.appendChild(createButton(f)));
            });

            if (Object.keys(currentData.files).length === 0) {
                 filesContainer.innerHTML = '<div class="alert alert-secondary">No sound files found in <code>soundboard/</code> folder.</div>';
            }
        }
    }

    // Events
    document.getElementById('guildSelect').onchange = (e) => {
        selectedGuildId = e.target.value;
        // Reset files container to force re-render (though files are global, maybe not needed?
        // Files are same for all guilds, so we don't need to re-render files.)

        // Reset volume slider to server value immediately
        if (currentData && currentData.status[selectedGuildId]) {
             const vol = currentData.status[selectedGuildId].volume;
             document.getElementById('volumeRange').value = vol;
             document.getElementById('volumeValue').textContent = vol + '%';
        }
        render(); // Re-render to update channels
    };

    document.getElementById('stopBtn').onclick = async () => {
        if (!selectedGuildId) return;
        await fetch('/api/soundboard/stop', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({guild_id: selectedGuildId})
        });
        await fetchData(); // Refresh status
    };

    document.getElementById('volumeRange').oninput = (e) => {
        document.getElementById('volumeValue').textContent = e.target.value + '%';
    };

    document.getElementById('volumeRange').onchange = async (e) => {
        if (!selectedGuildId) return;
        await fetch('/api/soundboard/volume', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({guild_id: selectedGuildId, volume: parseInt(e.target.value)})
        });
    };

    async function playSound(filePath) {
        if (!selectedGuildId) return;
        const channelId = document.getElementById('channelSelect').value;
        if (!channelId) {
            alert("Please select a voice channel!");
            return;
        }

        await fetch('/api/soundboard/play', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                guild_id: selectedGuildId,
                channel_id: channelId,
                file_path: filePath
            })
        });
        await fetchData();
    }

    // Initial load
    fetchData();
    // Refresh every 3 seconds to keep status updated
    setInterval(fetchData, 3000);

</script>
{% endblock %}
